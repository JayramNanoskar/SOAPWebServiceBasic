------------------------------------------------------- SOAP Web Services ----------------------------------------------------------
**Webservice types:
1.SOAP(Older) - specification for SOAP, called JAX-WS
2.REST(Newer) - specification for REST, called JAX-RS


**Webservice
-It is a service made available over the web.
-When we have specific business method in one application that we want different application to use. All we need to do is configure it as webservice.
-Webservice gives interoperatibility. Means C++ application can call Java or .Net webservice.
-We can have two different application written in different technologies that communicate with each other during execution time, they can call each others methods.


**Website vs Webservice:
-Website is meant for human consumption while Webservice is meant for code consumption or application level consumption.


**Need of webservice:
-To access functionality written in first application into second application. Here we can use jar by packaging first application.
-But in case first application functionality is making any database call, so there jar wont help because that data will be on different side.
Also in case we update first application then to access updated functionality we need to repackage application as jar file, then again build, redeploy to get on track.
-Hence, using direct call of functionality of first application using webservice is efficient.


**Web Service Jargon:
[Client App{SEI}]  -   [WSDL{XML-SOAP}]  -  [Webservice{SEI(i.e. Interface Implementation of service)}] 

-An interface is a standard way in which we can share any contract to consumer.
-Can we share web service implementation to consumer also using interface?
Webservice might be written in Java & Consumer might be in C++ or .Net or Java. So we cannot give interface written in Java to C++ or .Net developers. So contract must be technology independent. Hence this contract can be in xml format. We called it as WSDL(Web Service Description Language). This WSDL can be generated by manually or with the help of tools.
-WSDL contains high level information such as methods, arguments and return types also. It's like contract. So consumer application knows what to call.
-There are directories of web services where we can query and get information about web services, called UDDI(Universal Description Discovery and Integration)
-We can register our web service in UDDI and anybody who wants to consume webservice, can query directory and can use web service. 
-SOAP(Simple Object Access Protocol) is a way in which different technology can access data in language neutral format i.e xml.
There is specification about how to send data.
-SEI(Service Endpoint Interface) is a interface at client application to the web service endpoint which translate the whole web service calls to a soap message/xml and then it makes sure that the other end understand that message.
We don't need to write SEI class by ourselves, but we can have it automatically generated for us. We will have SEI written in same language in which our client app is, so it knows how to convert currently using language object to soap message. So it takes care all webservice complexity. 

1.WSDL:
WSDL describes what the webservice is in xml format that different technology can understand. WSDL is a interface to webservice.

2.UDDI:
UDDI is directory where any publisher can publish their web services and consumer can query these directory and get access to all the different webservices.

3.SOAP:
SOAP is a protocol, it's a language, it's a xml format that is used to encode and decode different messages.

4.SEI:
SEI is an interface to the endpoint. It's an interface to the webservice that provides a way for your client application irrespective of technology to call the webservice. So depending on technology we get SEI for that technology. So java application has java SEI, .net application has .net SEI. We can generate SEI out of the WSDL itself and further our code can use it. In JDK 1.8, we can use wsimport tool to generate SEI(also called Stub generation) from WSDL.


**Writing a Web service Client-Stub generation:
-Some sample webservice APIs are
https://www.dataaccess.com/webservicesserver/TextCasing.wso
https://www.dataaccess.com/webservicesserver/NumberConversion.wso
-In JDK 1.8, we can use wsimport tool to generate stubs from wsdl.
$ wsimport -keep -s src https://www.dataaccess.com/webservicesserver/NumberConversion.wso?WSDL


**Writing a Web service Client-Calling the Service:
1.Create the new instance of class marked as Service name in WSDL.
2.Use a method of that class to get instance of the port, Service will have port in WSDL. So we can use that name to get hold of actual port.
3.Then we can call methods on port to make actual webservice call.


**Setting up Java EE 8 SDK in developement environment:
-Prerequisites:
1.JRE or JDK must be present in system.
2.Make sure JAVA_HOME is set. We can check on cmd as echo %$AVA_HOME. Also JAVA_HOME must point to JRE or JDK directory.
-Glassfish server is an open-source application server that comes with Java EE SDK installation.
-After installtion it creates default domain - domain1 with admin port - 4848. Domain is like container where we can deploy our web application.
-To start the glassfish server, we can use asadmin utility as -> 
E:\Software\java_ee_sdk-8u1\glassfish5\bin> asadmin.bat start-domain [domain_name]
-To start the glassfish server, we can use asadmin utility as -> asadmin.bat stop-domain [domain_name]
-We can aceess Glassfish server administrative console at
http://localhost:4848/



**Writing a Web Service-Eclipse setup:
-Configure Glassfish server/Any server in IDE, So that we can deploy application from IDE itself.
-If Glassfish plugin is not visible in eclipse server then we can get it from Eclipse markerplace.


**Writing a Web Service-Code and Deploy:
-Conside, Creating a webservice that returns a product information for an e-commerce application.
-Create class & write desired functionality.
-Make class as a webservice. We can do it with annotation @Webservices on class. So every public method in these class is going to be exposed as webservice operation, no need to add optional annotation @WebMethod but incase we do not want to publish method as operation then we can use @WebMethod(exclude=true).
-Then Deploy webservice on webserver and
-Test webservice on webserver.


**Adding Webservice operations:
-Every webservice call for containing any operation we make is usually works on same instance & we get updated values for that instance.


**Service First and Contract First Web Services:
-Two traditional approaches to write webservices are 
1.Service/code First approach and 
2.Contract First approach.
-Service First/code first approach - writing service implementation and then generating WSDL. It is ideal for learning webservices.
-Contract First approach - writing WSDL and then service implementation. It is ideal for real world production scenarios because there may be lots of client going to use service implementation so first fixing down WSDL first then share it with all the consumers and then write service implementation. Afterwards we can change the service implementation without changing WSDL.
-In WSDL first approach, writing a throwaway java class first can give us a good starting point. Then we can generate WSDL and after tweaking WSDL as per requirement, we can finalized that WSDL.


**Understanding the WSDL:
	Service  
		↓
	  Port	→  Binding  → Port Type
							  ↓
						   Operations
						   ↓		↓
				Input Message	    Output Message
				↓		↓					↓
				Types	Types			  Types
	  


**Customizing the WSDL:
-Using annotation with properties, we can customize the resultant WSDL.
-Namespace in xml is like package in java. It groups all the xml types together.


**Schema Types and Binding Styles:
-Binding section in WSDL is like the way to configure what goes into webservice and what comes out of webservice.
-For webservice, 'DOCUMENT' style is the default SOAP binding. We can use the annotation, @SOAPBinding annotation on class to change to the 'RPC' style.
-With RPC style, there won't be any external document/xsd reference(for input, output types) inside <types> xml tag in WSDL, everything will be inline.
-With DOCUMENT style, we get xsd schema, we can actually validate that schema. So, in case of more complexity, it is recommended to use 'DOCUMENT' style because that gives us separate xsd document which can be validated. Hence soap request & response will be validated against xsd.


**Service Interface and Custom Types:
-Inside webservice class, we can avoid using all of the annotations but for that webservice class must implement an interface 
having all methods & require annotations and also then webservice class need to add only one annotation , @Webservice(endpointInterface="interface_fully_qualified_path", portName="port_name", serviceName="service_name") for knowing exact endpoint. Here that interface works as SEI(Service Endpoint Interface).
-Using Service Endpoint Interface is best practice because it decouples WSDL from actual implementation.


**Using JAXB Annotations:
-Java Architecture for XML Binding(JAXB) api helps to convert java objects to xml and xml code to java objects.
-To customize soap xml response we can use JAXB annotations.
-JAXB does XML to java object conversion too, Which is why it needs a no-arg constructor because it'll need to instantiate the object first.


**Handling Faults:
-For handling occured exceptions, <fault message> xml tag is used in wsdl. Fault messages get created for each exceptions thrown by Service method.
-Fault is webservice terminology for exception.
-It seems Glassfish server tester page has limitation while examine response when service throws an exception. It give us stacktrace instead XML response.


**Using SoapUI:
-We can test soap service inside webserver i.e. using Tester page inside glassfish webserver.
-SoapUI is client tool to test any soap webservices.


**Using Web Service Explorer:
-Web Service Explorer is eclipse IDE facility to test soap webservice.


**Using Endpoint:
-JAX-WS is a standard, it provides guidelines for us to write webservices and there are multiple JAX-WS implementations which takes the code we have written following the standard and it actually does the work of publishing the webservice.
-JAX-WS is standard which has many implementations like one of implementation is Metro implementation. Metro implementation is reference implementation, bydefault bundled with glassfish server. It takes care of deployed webservices. Also metro is bydefault bundled with JDK, So we can use Endpoint as Endpoint.publish("target_url", "service_class_instance") inside standalone java program to publish, access soap webservice quickly.
-Using Endpoint is quick way to test soap webservice but it is not recommended in production environment because of being single threaded but using any server like glassfish is recommended for production environment because of multithreaded support.



-----------------------------------------------------------------------------------------------------------------------------------------------------





